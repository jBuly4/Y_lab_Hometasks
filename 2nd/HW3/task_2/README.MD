Требования к задачам:

- Соответствует ожидаемому результату;
- Написаны без использования сторонних библиотек;
- Код соответствует PEP8;
- Импорты отсортированы правильно, неиспользуемых импортов нет;
- Отступы — 4 пробела;
- Длина строки меньше 119 символов;
- Переносы с правильными отступами;
- Бэкслеши для переносов не применяются;
- Консистентность: одинаковые кавычки, одинаковые методы решения одинаковых проблем;
- Отсутствие закомментированного кода;
- Комментарии к функциям оформлены в виде Docstrings в соответствии с Docstring Conventions: начинаются с большой буквы,
заканчиваются точкой и содержат описание того, что делает функция.
- Отсутствуют лишние операции;
- Нет лишних else там, где они не нужны. Например, если в if происходит return или raise;
- Если работа сдаётся в виде ссылки на github. В репозитории нет лишних файлов: __pycache__, .vscode и прочего;
- В f-строках применяется только подстановка переменных. Не применяйте логические или арифметические операции, вызовы 
функций и подобной динамики; 
- Исполняемый код в .py-файлах должен быть закрыт конструкцией if __name__ == ‘__main__’;
- Для неизменяемых последовательностей данных желательно применять кортежи, а не списки;
- Переменные названы в соответствии с их смыслом, по-английски, нет однобуквенных названий и транслита. В названии 
переменной не должен содержаться её тип — используйте type annotations. 

## 1. Задача на декоратор с кешированием результата

Напишите функцию-декоратор, которая сохранит (закэширует) значение декорируемой функции multiplier (Чистая функция). 
Если декорируемая функция будет вызвана повторно с теми же параметрами — декоратор должен вернуть сохранённый 
результат, не выполняя функцию.  

В качестве структуры для кэша, можете использовать словарь в Python.

*В качестве задания со звездочкой можете использовать вместо Python-словаря => Redis.

```python
def multiplier(number: int):
    return number * 2

```

## 2. Задача на декоратор с параметрами.
Надо написать декоратор для повторного выполнения декорируемой функции через некоторое время. Использует наивный 
экспоненциальный рост времени повтора (factor) до граничного времени ожидания (border_sleep_time). 

В качестве параметров декоратор будет получать:
- call_count - число, описывающее кол-во раз запуска функций;
- start_sleep_time - начальное время повтора;
- factor - во сколько раз нужно увеличить время ожидания;
- border_sleep_time - граничное время ожидания.

Формула:
- t = start_sleep_time * 2^(n) if t < border_sleep_time
- t = border_sleep_time if t >= border_sleep_time

Ожидаемый результат:
```python
Кол-во запусков = call_count (допустим 3)
Начало работы
Запуск номер 1. Ожидание: t секунд. Результат декорируемой функций = func_result.
Запуск номер 2. Ожидание: t секунд. Результат декорируемой функций = func_result.
...
Конец работы
```

## 3. Задача на рефакторинг кода.
Посмотреть код в репозиторий - [Несолидный код](https://github.com/BernarBerdikul/ylab_hw). И сделать рефакторинг 
кода в соответствиях с принципами SOLID. Проблемы кода написаны в комментариях в коде. 

Для проверки кода, запустите файл main.py в коде репозитория.